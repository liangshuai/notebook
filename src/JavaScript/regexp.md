# JS正则表达式

1、字符匹配

​	1.1、常⽤的元字符
​	1.2、量词
​	1.3、字符组
​	1.4、分⽀
​	1.5、字符匹配⽅式

2、位置匹配
	2.1、什么是位置匹配
	2.2、^和$
	2.3、\b和\B
	2.4、(?=p)和(?!p)
3、修饰符
	3.1、g
	3.2、i
	3.3、m
4、贪婪和惰性
	4.1、贪婪（尽可能多匹配）
	4.2、惰性（尽可能少匹配）
5、括号的作⽤
	5.1、分组(⼦表达式)
	5.2、分⽀
	5.3、捕获分组
	5.4、⾮捕获分组
6、零宽断⾔（前瞻）
7、正则表达式匹配原理
	7.1、原理
	7.2、没有回溯的匹配
	7.3、有回溯匹配
8、常⽤API
	8.1 search和match
	8.2 match返回结果
	8.3 exec
	8.4 replace

## 1、字符匹配

### 1.1、常⽤的元字符

元字符				 含义
\b 						匹配⼀个单词边界(boundary)
\B 						匹配⼀个⾮单词边界
\d 						匹配⼀个数字字符(digit)
\D 						匹配⼀个⾮数字字符
\s 						匹配⼀个空⽩字符(space)
\S 						匹配⼀个⾮空⽩字符
\w 						匹配⼀个字⺟或者⼀个数字或者⼀个下划线(word)
\W 						匹配⼀个字⺟、数字和下划线之外的字符
\n 						匹配换⾏
. 							匹配除换⾏符以外的任意字符
^ 							匹配字符串开始位置
$ 							匹配字符串结束位置
\ 							字符串转义

### 1.2、量词

量词也属于元字符。表示字符重复的次数。表示⽅式{m, n}。如：/\d{2,5}/，表示匹配数字，
重复2-5次。

量词			等价于							描述

{m,} 		  										表示出现m次或以上

{m} 			等价于{m,m} 				表示出现m次
? 				等价于{0,1} 					表示出现0次或1次

\+                 等价于{1,} 					 表示出现⾄少⼀次

\* 				等价于{0,} 					 表示出现0次或多次


### 1.3 字符组

⽤[]表示，或的逻辑，即匹配字符组⾥任意⼀个字符，例如[abc]，它可以是“a”、“b”、“c”之⼀。


字符组范围
连字符“-”表示范围。如：[a-zA-Z0-9]，表示匹配⼤⼩写字⺟和数字0-9。
要匹配字符“-”⾃身，则要转义或者放到字符组前⾯或后⾯。如果：[a\-b]或[ab-]
字符组取反

字符组开头⽤^, 表示取反。如：'aregex'.match(/[^ae]/g)，表示匹配除ae外的字符

特殊字符
字符组⾥⾯特殊字符可以不转义，[.^$／\-]。

### 1.4 分支

分⽀⽤|分隔，表示匹配⼦模式中任意⼀个。表示⽅式：(p1|p2|p3)，其中p1、p2和p3是⼦模式。
如果每个分⽀值匹配⼀个字符，等价于[]。

分⽀⼦模式可以是多个字符



### 1.5 字符匹配⽅式

横向匹配
匹配字符串，某个或者某⼏个字符出现的次数是不固定的，即⽤量词表示{m, n};
如：/ab{2}/ 匹配b出现2次
/(ab){2, 5}/ 匹配ab出现2-5次。
纵向匹配
单个字符的纵向匹配，⽤字符组。如：[abc]，表示a、b、c任意⼀个。
多个字符的纵向匹配，则要使⽤分⽀。如：/(ab|ac)a/ 表示aba、aca



## 2 位置匹配



位置是相邻字符之间的位置。

### 2.2、^和$

^匹配开头，在多⾏匹配中匹配⾏开头。
$匹配结尾，在多⾏匹配中匹配⾏结尾。

### 2.3、\b和\B

\b是单词边界，即\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置。
\B就是\b的反⾯的意思，⾮单词边界。例如在字符串中所有位置中，扣掉\b，剩下的都是\B的。

### 2.4、(?=p) 和(?!p)

零宽断⾔



## 3、 修饰符

### 3.1、g

默认从坐到右匹配，匹配到⼀个结果就停⽌。g开启全局匹配，会找到所有的匹配，单词是global

### 3.2、 i

忽略字⺟⼤⼩写，单词ingoreCase

### 3.3、m

多⾏匹配，遇到\n则分⾏，每⼀⾏都能匹配开始结束位置。单词是multiline



### 4、贪婪和惰性

量词（*, ?, +, {n}, {n,}, {n,m}）匹配是分贪婪和惰性的，默是贪婪匹配。量词后⾯加？则表示惰性。

### 4.1、贪婪（尽可能多匹配）

匹配到⼀个结果后，继续往后匹配，直到不满⾜条件为⽌。

```js
'123456xx'.match(/\d+/g);
// => ["123456"]
'123456xx'.match(/\d{2,5}/g);
// => ["12345"]
var str = '<img src="1.jpg" />aaa<img src="2.jpg" />';
var reg = /<img.*>/g;
str.match(reg);
// => ["<img src="1.jpg" />aaa<img src="2.jpg" />"]
```

### 4.2、惰性（尽可能少匹配）

匹配到⼀个结果后则停⽌。

```js
// 匹配数字
'123456xx'.match(/\d+?/g);
// => ["1", "2", "3", "4", "5", "6"]
'123456xx'.match(/\d{2,5}?/g);
// => ["12", "34", "56"]
// 匹配img标签
var str = '<img src="1.jpg" />aaa<img src="2.jpg" />';
var reg = /<img.*?>/g;
str.match(reg);
// ["<img src="1.jpg" />", "<img src="2.jpg" />"]
// 也可以这样写
// var reg = /<img[^>]*>/g;
```


## 5、括号的作⽤

### 5.1、分组(⼦表达式)

如果需要匹配多个字符，则需使⽤分组，括号⾥⾯的表达式则叫⼦表达式。

```js
1 var reg = /(ab)+/g;
2 var str = "ababa abbb ababab";
3 str.match(reg)
4 // => ["abab", "ab", "ababab"]
```

### 5.2、分⽀

可以作为⼀个分⽀使⽤。
如：匹配北京座机(010-xxxxxxx)和⼴州座机(020-xxxxxxxx)

```js
1 var reg = /^((010)|(020))-\d{8}$/g;
2 // var reg = /^(0[12]0)-\d{8}$/g
3 reg.test('020-23456784');
```

### 5.3、捕获分组

* 表达式外捕获
  即对⼦表达式的匹配结果进⾏引⽤，可⽤于数据提取和字符串替换。

1. 数据提取
  使⽤字符串的match()，或者正则的exec()⽅法

  ```js
  1 var reg = /(\d{4})-(\d{2})-(\d{2})/;
  2 var str = '2019-10-29';
  3 str.match(reg);
  4 // => ["2019-10-29", "2019", "10", "29", index: 0, input: "2019-10-29", groups: undefined]
  5 reg.exec(str);
  6 // => ["2019-10-29", "2019", "10", "29", index: 0, input: "2019-10-29", groups: undefined]
  ```

  

2. 字符串替换
  ⽤$1,$2,$3…$9表示分组匹配的结果，或⽤全局变量Regexp.$1,Regexp.$2,…Regexp.$9表示。
  如：替换p标签为span

  ```js
  1 var str = '<p class="p">xxx</p><div>ddd</div><p title="hehhe"></p>';
  2 var reg = /<(\/?)p(.*?)>/g;
  3 str.replace(reg, '<$1span$2>');
  4 // => "<span class="p">xxx</span><div>ddd</div><span title="hehhe"></span>"
  ```

* 表达式内捕获(反向引⽤)
  正则表达式中，对括号⾥⾯的⼦表达式进⾏引⽤。\1,\2,\3…\9。
  如：匹配⽇前格式：2019-10-29，2019/10/29，2019.10.29
  不严瑾的写法

  ```js
  1 var reg = /^\d{4}[./-]\d{2}[./-]\d{2}$/
  2 reg.test('2019-10-29');
  3 reg.test('2019/10/29');
  4 reg.test('2019.10.29');
  5 // => true
  6
  7 reg.test('2019.10/29');
  8 // => true
  ```

  

  严瑾的写法

  ```js
  1 var reg = /^\d{4}([/.-])\d{2}\1\d{2}$/
  2 reg.test('2019-10-29');
  3 reg.test('2019/10/29');
  4 reg.test('2019.10.29');
  5 // => true
  6
  7 reg.test('2019.10/29');
  8 // => false
  ```

  ### 5.4、⾮捕获分组

  捕获分组的作⽤，⽅便后续引⽤。如果不想引⽤，则使⽤⾮捕获分组(?:p) 。
  ⾮捕获分组可以节省内存消耗。
  如：修改前⾯的表达式

  ```js
  1 var str = '<p class="p">xxx</p><div>ddd</div><p title="hehhe"></p>';
  2 var reg = /<(?:\/?)p(?:.*?)>/g;
  3 str.replace(reg, '<$1span$2>');
  4 // "<$1span$2>xxx<$1span$2><div>ddd</div><$1span$2><$1span$2>"
  ```

  

  ## 6、零宽断⾔（前瞻）

  有时要匹配某个位置之前或之后应该有什么内容，叫零宽断⾔。
  零宽(zero-width)是什么意思？指的就是它匹配⼀个位置，本身没有宽度。
  断⾔(assertion)是什么意思？指的是⼀种判断，断⾔之前或之后应该有什么或应该没有什么。

  表达式			名称									描述
  (?=exp) 		  正向前瞻							匹配后⾯满⾜表达式exp的位置
  (?:exp) 			负向前瞻							匹配后⾯不满⾜表达式exp的位置
  (?<=exp) 		正向后瞻							匹配前⾯满⾜表达式exp的位置（JS不⽀持）
  (?<!exp) 		负向后瞻							匹配前⾯不满⾜表达式exp的位置（JS不⽀持）

  

  ```js
  1 var reg1 = /bed(?=room)/ // 匹配bed后面为room的字符串。
  2 var reg2 = /bed(?!room)/ // 匹配bed后面不为room的字符串
  3 var str1 = ‘bedroom’;
  4 var str2 = ‘bedding’;
  5 reg1.test(str1);
  6 reg2.test(str2);
  ```

  如下例⼦，更能体现零宽断⾔，匹配的是⼀个位置。

  ```js
  1 var reg = /a(?=b)c/;
  2 var str = "abc";
  3 str.match(reg);
  4 // => null
  ```

  第1步：匹配表达式a通过
  第2步：匹配表达式(?=b)也通过
  第3步：匹配表达式c，是从“abc”的b位置开始匹配，此时匹配到的是ac，不通过。
  第4步：从字符串“abc”的b继续开始匹配，不通过。
  第5步：从字符串“abc”的c继续开始匹配，不通过。


  改成如下则通过。

  ```js
  1 var reg = /a(?=b)bc/;
  2 var str = "abc";
  3 str.match(reg);
  4 // => ["abc", index: 0, input: "abc", groups: undefined]
  ```

  

  应⽤：去掉除表情外的富⽂本。

  ```js
  1 // 清空不包含class=“w_emoji”的的html标签
  2 var str = `
  3 <div class="wrap">
  4 <img class="w_emoji" src="xxxxxx" title="表情"/>
  5 <p>pppp</p>
  6 <h3><strong>h3h3h3</strong></h3>
  7 <img calss="b" src="dddd" />
  8 </div>
  9 `;
  10 var reg = /<(?!img class="w_emoji").*?>/gi;
  11 str.replace(reg, '');
  12
  13 // <img class="w_emoji" src="xxxxxx" title="表情"/>
  14 // pppp
  15 // h3h3h3
  ```

  

  ## 7、正则表达式匹配原理

  ### 7.1、原理

  正则表达式匹配字符串的这种⽅式，叫回溯法。
  回溯法也称试探法，它的基本思想是：从问题的某⼀种状态（初始状态）出发，搜索从这种状态出发所能
  达到的所有“状态”，当⼀条路⾛到“尽头”的时候（不能再前进），再后退⼀步或若⼲步，从另⼀种可能“状
  态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的⽅
  法，就称作“回溯法”。（copy于百度百科）。

  ### 7.2 没有回溯的匹配

  假设我们的正则是/ab{1,3}c/ ，其可视化形式是：

  当⽬标字符串是"abbbc"时，就没有所谓的“回溯”。其匹配过程是：
  其中⼦表达式b{1,3} 表示“b”字符连续出现1到3次。

  

  ### 7.3、有回溯匹配

  如果⽬标字符串是"abbc"，中间就有回溯。

  图中第5步有红颜⾊，表示匹配不成功。此时b{1,3} 已经匹配到了2个字符“b”，准备尝试第三个时，结
  果发现接下来的字符是“c”。那么就认为b{1,3} 就已经匹配完毕。然后状态⼜回到之前的状态（即第6
  步，与第4步⼀样），最后再⽤⼦表达式c ，去匹配字符“c”。当然，此时整个表达式匹配成功了。
  量词和分⽀都可能会出现回溯现象。

  

  ## 8、常⽤API

  

* String#search
* String#match
* String#split
* String#replace
* RegExp#test
* RegExp#exec

### 8.1 search和match

String的4个⽅法，都⽀持正则表达式，search和match会把字符串⾃动转成正则表达式。

```js
1 var string = "2017.06.27";
2
3 console.log( string.search(".") );
4 // => 0
5 //需要修改成下列形式之一
6 console.log( string.search("\\.") );
7 console.log( string.search(/\./) );
8 // => 4
9 // => 4
10
11 console.log( string.match(".") );
12 // => ["2", index: 0, input: "2017.06.27"]
13 //需要修改成下列形式之一
14 console.log( string.match("\\.") );
15 console.log( string.match(/\./) );
16 // => [".", index: 4, input: "2017.06.27"]
17 // => [".", index: 4, input: "2017.06.27"]
```

### 8.2 match返回结果

返回的结果的格式，与正则对象是否有修饰符g有关。

1. 没有g，返回的是标准匹配格式，即，数组的第⼀个元素是整体匹配的内容，接下来是分组捕获的内
  容，然后是整体匹配的第⼀个下标，最后是输⼊的⽬标字符串。
2. 有g，返回的是所有匹配的内容。
3. 当没有匹配时，不管有⽆g，都返回null。

```js
1 var reg1 = /\d([a-z])/;
2 var reg2 = /\d([a-z])/g;
3 var str = '12ab34ef';
4 str.match(reg1);
5 // => ["2a", "a", index: 1, input: "12ab34ef", groups: undefined]
6 str.match(reg2);
7 // => ["2a", "4e"]

```



### 8.3 exec

⾮全局模式下，exec和match返回的结果是⼀样的。
全局模式下(g)，可多次执⾏，匹配下标会不断变化，此值作为下次匹配的开始。下标也可以通过正则实例
访问，如：reg.lastindex

```js
1 var reg1 = /\d([a-z])/;
2 var reg2 = /\d([a-z])/g;
3 var str = '12ab34ef';
4 reg1.exec(str);
5 // => ["2a", "a", index: 1, input: "12ab34ef", groups: undefined]
6
7 reg2.exec(str);
8 // => ["2a", "a", index: 1, input: "12ab34ef", groups: undefined]
9 reg2.exec(str);
10 // => ["4e", "e", index: 5, input: "12ab34ef", groups: undefined]
11 reg2.exec(str);
12 // => null
```

### 8.4 replace

语法（str.replace(regexp|substr, newSubStr|function)）
第⼀个参数可为字符或者正则表达式。
第⼆个参数可以是要替换的字符串，或者⼀个函数，该函数的返回值将替换掉第⼀个参数匹配到的结
果。
函数的参数



变量名							代表的值
match 							匹配的⼦串。（对应于上述的$&。）
p1,p2, ... 						假如replace()⽅法的第⼀个参数是⼀个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）例如，如果是⽤ /(\a+)
(\b+)/ 这个来匹配， p1 就是匹配的 \a+ ， p2 就是匹配的 \b+ 。
offset 							匹配到的⼦字符串在原字符串中的偏移量。（⽐如，如果原字符串
是 'abcd' ，匹配到的⼦字符串是 'bc' ，那么这个参数将会是 1）
string 							被匹配的原字符串。
NamedCaptureGroup 命名捕获组匹配的对象